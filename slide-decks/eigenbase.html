<!doctype html>
<html lang="pt-BR">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>√Ålgebra Linear: O C√≥digo-Fonte</title>
    <!-- Links para CDNs e CSS externo -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.3.1/dist/reveal.min.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=VT323&display=swap" rel="stylesheet" />
    <link rel="stylesheet" href="game-theme.css" />
    <!-- Scripts para Reveal.js e MathJax -->
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.3.1/dist/reveal.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.3.1/plugin/math/math.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  </head>

  <body>
    <div class="reveal">
      <div class="background-grid"></div>
      <div class="ghost"></div>
      <div class="ghost"></div>

      <div class="slides">
        <!-- =========================== -->
        <!-- SLIDE DE T√çTULO DA FASE -->
        <!-- =========================== -->
        <section>
          <h1>Fase Final: O C√≥digo-Fonte</h1>
          <h3>Autovalores e Autovetores</h3>
          <p class="press-start">Pressione Enter para come√ßar</p>
        </section>

        <!-- =========================== -->
        <!-- SLIDES DE LORE (DIVIDIDOS)-->
        <!-- =========================== -->
        <section>
            <!-- Slide de Lore 1: Dev Log -->
            <section>
                <h2>Lore da Fase: Dev Log</h2>
                <div class="lore-section">
                    <div class="lore-label">DEV LOG</div>
                    <p><strong>Desenvolvedor Original: Augustin-Louis Cauchy (~1820s)</strong></p>
                    <p>
                    Cauchy, ao estudar as superf√≠cies qu√°dricas, foi um dos primeiros a entender que certas "transforma√ß√µes" (matrizes) possu√≠am eixos principais que n√£o mudavam de dire√ß√£o. Ele descobriu as "frequ√™ncias secretas" do universo matem√°tico, que mais tarde seriam chamadas de autovalores.
                    </p>
                </div>
            </section>

            <!-- Slide de Lore 2: A Mec√¢nica -->
            <section>
                <h2>Lore da Fase: A Mec√¢nica</h2>
                <div class="lore-section">
                    <div class="lore-label">A MEC√ÇNICA</div>
                    <p><strong>Desafio do Jogo: O Comportamento Oculto</strong></p>
                    <p>
                    At√© agora, vimos transforma√ß√µes como "Power-ups" que movem e distorcem nossos "Avatares" (vetores). Mas algumas transforma√ß√µes t√™m um segredo: existem dire√ß√µes especiais, "Caminhos √ìtimos", que n√£o s√£o rotacionadas. Um avatar nessa dire√ß√£o apenas cresce ou encolhe. Encontrar esses caminhos e seus fatores de escala √© como acessar o c√≥digo-fonte da transforma√ß√£o, revelando sua ess√™ncia.
                    </p>
                </div>
            </section>
        </section>

        <!-- ============================================== -->
        <!-- QUEST 6.1: Autovalores e Autovetores -->
        <!-- ============================================== -->
        <section>
          <!-- Bloco 1: Defini√ß√£o e Intui√ß√£o -->
          <section>
            <h2>Mec√¢nica: Autovalores e Autovetores</h2>
            <div class="math-section">
              <p>Um **autovetor** de uma matriz \(A\) √© um vetor n√£o nulo \(v\) que, quando multiplicado por \(A\), resulta em um m√∫ltiplo escalar de si mesmo. O escalar, \(\lambda\), √© o **autovalor** correspondente.</p>
              <p>\[Av = \lambda v\]</p>
            </div>
            <p class="game-interp">
              <strong>Interpreta√ß√£o no Jogo:</strong> O **Autovetor** (\(v\)) √© um "Caminho √ìtimo". Quando a transforma√ß√£o \(A\) age sobre ele, ele n√£o muda de dire√ß√£o. O **Autovalor** (\(\lambda\)) √© a "Frequ√™ncia Secreta", o fator pelo qual o caminho √© esticado ou encolhido.
            </p>
          </section>

          <section>
            <h2>Demo: Caminho √ìtimo</h2>
            <canvas id="eigenvectorVisualization" class="visualization-canvas" width="600" height="400"></canvas>
            <div class="controls-container">
              <button class="control-button" onclick="applyTransformation()">Aplicar Transforma√ß√£o</button>
              <button class="control-button" onclick="resetTransformation()">Reset</button>
            </div>
          </section>
          
          <section>
            <h2>Dica: Onde Est√£o os Caminhos √ìtimos?</h2>
             <div class="lore-section">
                 <div class="lore-label">DICA DO MESTRE DO JOGO</div>
                 <p>Toda transforma√ß√£o tem um "Caminho √ìtimo"?</p>
                 <ul>
                    <li><strong>Rota√ß√£o (em 2D):</strong> Pense em girar o plano em 90¬∞. Algum vetor (exceto o zero) aponta para a mesma dire√ß√£o de antes? N√£o! Uma rota√ß√£o pura em 2D <strong>n√£o tem autovetores reais</strong>. Ela muda a dire√ß√£o de todo mundo!</li>
                    <li class="fragment"><strong>Proje√ß√£o:</strong> Imagine projetar todos os vetores sobre o eixo X.
                        <ul>
                            <li>Um vetor que j√° est√° no eixo X (ex: [1, 0]) n√£o muda. Ele √© um autovetor com autovalor \(\lambda=1\).</li>
                            <li>Um vetor no eixo Y (ex: [0, 1]) √© esmagado na origem. Ele vira o vetor [0, 0]. Isso conta! \(A v = 0 \cdot v\). Ele √© um autovetor com autovalor \(\lambda=0\).</li>
                        </ul>
                    </li>
                 </ul>
             </div>
          </section>

          <section>
            <h2>Regra Especial: Polin√¥mio Caracter√≠stico</h2>
            <div class="math-section">
              <p>Para encontrar os autovalores, reescrevemos a equa√ß√£o como \((A - \lambda I)v = 0\). Para que exista uma solu√ß√£o n√£o nula para \(v\), a matriz \((A - \lambda I)\) deve ser singular, ou seja, seu determinante deve ser zero.</p>
              <p>\[\det(A - \lambda I) = 0\]</p>
              <p>Esta √© a **equa√ß√£o caracter√≠stica**. O lado esquerdo √© o **polin√¥mio caracter√≠stico** de \(A\).</p>
            </div>
          </section>

          <!-- Bloco 2: C√°lculo -->
          <section>
            <h2>Mec√¢nica: Roteiro para Autovalores</h2>
            <div class="math-section">
              <h4>Sequ√™ncia de Comandos (Autovalores):</h4>
              <ol>
                <li>A partir da matriz \(A\), construa a matriz \(A - \lambda I\).</li>
                <li>Calcule o determinante: \(\det(A - \lambda I)\).</li>
                <li>Resolva a equa√ß√£o \(\det(A - \lambda I) = 0\) para encontrar as ra√≠zes \(\lambda\). Estas s√£o as "Frequ√™ncias Secretas" (autovalores).</li>
              </ol>
            </div>
          </section>

          <section>
            <h2>Mec√¢nica: Roteiro para Autovetores</h2>
            <div class="math-section">
              <h4>Sequ√™ncia de Comandos (Autovetores):</h4>
              <ol>
                <li>Para <strong>cada autovalor</strong> \(\lambda\) que voc√™ encontrou:</li>
                <li>Substitua o valor de \(\lambda\) na equa√ß√£o \((A - \lambda I)v = 0\).</li>
                <li>Resolva o sistema linear homog√™neo resultante. As solu√ß√µes n√£o nulas s√£o os "Caminhos √ìtimos" (autovetores) associados √†quele \(\lambda\).</li>
              </ol>
            </div>
          </section>

          <section>
            <h2>Desafio: Quest de Treinamento</h2>
            <div class="problem-section">
              <h4>üéØ Quest de Treinamento (F√°cil)</h4>
              <p>Encontre os autovalores e os autovetores correspondentes da matriz:</p>
              <p>\[ A = \begin{pmatrix} 4 & -2 \\ 1 & 1 \end{pmatrix} \]</p>
            </div>
          </section>

          <section>
            <h2>Guia: Estrat√©gia (F√°cil)</h2>
            <div class="compact-solution">
              <h4>Estrat√©gia para a Quest de Treinamento:</h4>
              <ol>
                <li>Polin√¥mio Caracter√≠stico: \(\det(A - \lambda I) = (4-\lambda)(1-\lambda) - (-2)(1) = \lambda^2 - 5\lambda + 6 = 0\).</li>
                <li>Autovalores: As ra√≠zes s√£o \(\lambda_1 = 2\) e \(\lambda_2 = 3\).</li>
                <li>Autovetor para \(\lambda_1 = 2\): Resolva \((A-2I)v = 0\). O autoespa√ßo √© gerado por \(v_1 = \begin{pmatrix} 1 \\ 1 \end{pmatrix}\).</li>
                <li>Autovetor para \(\lambda_2 = 3\): Resolva \((A-3I)v = 0\). O autoespa√ßo √© gerado por \(v_2 = \begin{pmatrix} 2 \\ 1 \end{pmatrix}\).</li>
              </ol>
            </div>
          </section>
          
          <!-- Bloco 3: Briot-Ruffini -->
          <section>
             <h2>Dica do Mestre do Jogo</h2>
             <div class="lore-section">
                 <div class="lore-label">DICA</div>
                 <p>Para matrizes 3x3 ou maiores, voc√™ encontrar√° um "Puzzle de Polin√¥mio C√∫bico". Resolver \(\det(A-\lambda I)=0\) pode ser dif√≠cil.</p>
                 <p>Um item especial, a "Sequ√™ncia de Comandos de Briot-Ruffini", pode te ajudar a reduzir o grau do polin√¥mio para encontrar suas ra√≠zes!</p>
             </div>
          </section>
          
          <section>
            <h2>Mec√¢nica: Algoritmo de Briot-Ruffini</h2>
            <div class="math-section">
               <p>Para resolver \(P(\lambda) = a_n\lambda^n + \dots + a_0 = 0\), teste as ra√≠zes candidatas (divisores de \(a_0\)). Se \(P(r) = 0\), use o algoritmo para dividir \(P(\lambda)\) por \((\lambda-r)\).</p>
               <p>Exemplo: \(P(\lambda) = \lambda^3 - 6\lambda^2 + 11\lambda - 6 = 0\). Teste \(\lambda=1\): \(1-6+11-6=0\). Funciona!</p>
               <p>
                 <pre style="font-family: 'VT323', monospace; font-size: 1.2em; text-align: left; margin-left: 15%;">
  1 | 1  -6  +11  -6
----|-----------------
    | 1  -5    6   0
                 </pre>
               </p>
               <p>O resultado √© \(\lambda^2 - 5\lambda + 6 = 0\), cujas ra√≠zes s√£o \(\lambda=2\) e \(\lambda=3\). As ra√≠zes totais s√£o 1, 2 e 3.</p>
            </div>
          </section>

          <!-- Bloco 4: Aplicando Briot-Ruffini -->
          <section>
            <h2>Desafio: Miss√£o Principal</h2>
            <div class="problem-section">
              <h4>‚öîÔ∏è Miss√£o Principal (M√©dio)</h4>
              <p>Encontre os autovalores da matriz \(A\):</p>
              <p>\[ A = \begin{pmatrix} 4 & 0 & 1 \\ -2 & 1 & 0 \\ -2 & 0 & 1 \end{pmatrix} \]</p>
            </div>
          </section>

          <section>
            <h2>Guia: Estrat√©gia (M√©dio)</h2>
            <div class="compact-solution">
              <h4>Estrat√©gia para a Miss√£o Principal:</h4>
              <ol>
                <li>Polin√¥mio caracter√≠stico: \(\det(A-\lambda I) = -\lambda^3 + 6\lambda^2 - 11\lambda + 6 = 0\).</li>
                <li>Divida por -1: \(\lambda^3 - 6\lambda^2 + 11\lambda - 6 = 0\).</li>
                <li>Teste ra√≠zes candidatas (divisores de 6). Para \(\lambda=1\), o resultado √© 0.</li>
                <li>Use Briot-Ruffini para dividir por \((\lambda-1)\), resultando em \(\lambda^2 - 5\lambda + 6\).</li>
                <li>As ra√≠zes da quadr√°tica s√£o \(\lambda=2\) e \(\lambda=3\). Os autovalores s√£o \(\lambda_1 = 1, \lambda_2 = 2, \lambda_3 = 3\).</li>
              </ol>
            </div>
          </section>

          <section>
            <h2>Recompensa da Quest</h2>
            <p>Parab√©ns, voc√™ decifrou o c√≥digo-fonte!</p>
            <div class="math-section">
                <p><strong>Itens Adquiridos (Conceitos-Chave):</strong></p>
                <ul>
                    <li>Defini√ß√£o de Autovalor (\(\lambda\)) e Autovetor (\(v\)): \(Av = \lambda v\).</li>
                    <li>Polin√¥mio Caracter√≠stico: \(\det(A - \lambda I) = 0\).</li>
                    <li>Algoritmo de Briot-Ruffini para encontrar ra√≠zes.</li>
                </ul>
            </div>
            <p>Voc√™ agora entende a ess√™ncia de uma transforma√ß√£o linear!</p>
          </section>
        </section>

        <!-- ============================================== -->
        <!-- QUEST 6.2: Diagonaliza√ß√£o -->
        <!-- ============================================== -->
        <section>
          <!-- Bloco 1: Mudan√ßa de Base -->
          <section>
              <h2>Mec√¢nica: Revis√£o - Mudan√ßa de Base</h2>
              <div class="math-section">
                  <p>Lembre-se da Fase 5: se temos uma transforma√ß√£o \(A\) na base can√¥nica, e queremos v√™-la de uma nova base \(B\), a nova matriz da transforma√ß√£o, \(M_B\), √©:</p>
                  <p>\[ M_B = P^{-1} A P \]</p>
                  <p>Onde \(P\) √© a matriz de mudan√ßa da base \(B\) para a base can√¥nica (suas colunas s√£o os vetores da base \(B\)).</p>
              </div>
              <p class="game-interp">
                  <strong>Interpreta√ß√£o no Jogo:</strong> √â como colocar um "√≥culos" diferente para ver o mundo. O mundo n√£o muda, mas nossa descri√ß√£o dele sim. \(P\) traduz da nova vis√£o para a antiga, \(A\) age no mundo antigo, e \(P^{-1}\) traduz de volta para a nova vis√£o.
              </p>
          </section>

          <!-- Bloco 2: A Base Perfeita -->
          <section>
              <h2>Regra Especial: A Base de Autovetores</h2>
              <div class="math-section">
                  <p>E se usarmos um "Conjunto de Habilidades" (Base) especial, formado apenas pelos "Caminhos √ìtimos" (Autovetores)? Essa base √© chamada de **Eigenbase**.</p>
                  <p>A pergunta √©: Como a transforma√ß√£o \(A\) se parece quando vista atrav√©s dos "√≥culos" da Eigenbase?</p>
              </div>
          </section>

          <section>
              <h2>Mec√¢nica: A Transforma√ß√£o na Eigenbase</h2>
              <div class="math-section">
                  <p>Na Eigenbase, a a√ß√£o da transforma√ß√£o √© super simples! Cada vetor da base √© apenas esticado ou encolhido pelo seu autovalor correspondente. A matriz da transforma√ß√£o nessa base se torna uma **matriz diagonal** \(D\)!</p>
                  <p>\[ D = \begin{pmatrix} \lambda_1 & 0 & \dots \\ 0 & \lambda_2 & \dots \\ \vdots & \vdots & \ddots \end{pmatrix} \]</p>
                  <p>Usando a f√≥rmula de mudan√ßa de base, com \(P\) sendo a matriz dos autovetores, temos:</p>
                  <p>\[D = P^{-1} A P\]</p>
              </div>
              <p class="game-interp"><strong>Momento "Aha!":</strong> A diagonaliza√ß√£o n√£o √© um truque, √© simplesmente **olhar para a transforma√ß√£o a partir da sua pr√≥pria base preferencial!**</p>
          </section>

          <!-- Bloco 3: Diagonaliza√ß√£o -->
          <section>
            <h2>Mec√¢nica: Ativando o "Modo Deus"</h2>
            <div class="math-section">
              <p>Reorganizando a f√≥rmula anterior, obtemos a forma da **diagonaliza√ß√£o**:</p>
              <p>\[A = PDP^{-1}\]</p>
              <p>Isso nos d√° um poder incr√≠vel. Para calcular \(A^k\):</p>
              <p>\[A^k = (PDP^{-1})(PDP^{-1})\dots(PDP^{-1}) = PD^kP^{-1}\]</p>
              <p>Calcular \(D^k\) √© trivial: basta elevar os elementos da diagonal!</p>
            </div>
          </section>

          <section>
            <h2>Desafio: Miss√£o Principal</h2>
            <div class="problem-section">
              <h4>‚öîÔ∏è Miss√£o Principal (M√©dio)</h4>
              <p>Diagonalize a matriz \(A\) da Quest anterior:</p>
              <p>\[ A = \begin{pmatrix} 4 & -2 \\ 1 & 1 \end{pmatrix} \]</p>
              <p>Lembre-se: \(\lambda_1=2, v_1=\begin{pmatrix} 1 \\ 1 \end{pmatrix}\); \(\lambda_2=3, v_2=\begin{pmatrix} 2 \\ 1 \end{pmatrix}\).</p>
            </div>
          </section>

          <section>
            <h2>Guia: Estrat√©gia (M√©dio)</h2>
            <div class="compact-solution">
              <h4>Estrat√©gia para a Miss√£o Principal:</h4>
              <ol>
                <li>A Eigenbase √© formada por \(v_1\) e \(v_2\). A matriz de mudan√ßa de base \(P\) tem esses vetores como colunas: \(P = \begin{pmatrix} 1 & 2 \\ 1 & 1 \end{pmatrix}\).</li>
                <li>Na Eigenbase, a transforma√ß√£o √© a matriz diagonal \(D\) com os autovalores correspondentes: \(D = \begin{pmatrix} 2 & 0 \\ 0 & 3 \end{pmatrix}\).</li>
                <li>A diagonaliza√ß√£o √© a express√£o \(A = PDP^{-1}\). Encontrar \(P^{-1}\) completa o processo.</li>
              </ol>
            </div>
          </section>

          <section>
            <h2>Desafio: Desafio Avan√ßado</h2>
            <div class="problem-section">
              <h4>‚ò†Ô∏è Desafio Avan√ßado (Complexo)</h4>
              <p>Usando a diagonaliza√ß√£o que voc√™ acabou de encontrar, calcule \(A^5\).</p>
            </div>
          </section>

          <section>
            <h2>Guia: Estrat√©gia (Avan√ßado)</h2>
            <div class="compact-solution">
               <h4>Estrat√©gia para o Desafio Avan√ßado:</h4>
              <ol>
                <li>Use a f√≥rmula do "Modo Deus": \(A^5 = PD^5P^{-1}\).</li>
                <li>Calcule \(D^5\): \(D^5 = \begin{pmatrix} 2^5 & 0 \\ 0 & 3^5 \end{pmatrix} = \begin{pmatrix} 32 & 0 \\ 0 & 243 \end{pmatrix}\).</li>
                <li>A inversa de P √© \(P^{-1} = \begin{pmatrix} -1 & 2 \\ 1 & -1 \end{pmatrix}\).</li>
                <li>Fa√ßa a multiplica√ß√£o: \(A^5 = \begin{pmatrix} 1 & 2 \\ 1 & 1 \end{pmatrix} \begin{pmatrix} 32 & 0 \\ 0 & 243 \end{pmatrix} P^{-1} = \begin{pmatrix} 454 & -422 \\ 211 & -179 \end{pmatrix}\).</li>
              </ol>
            </div>
          </section>

          <section>
            <h2>Recompensa da Quest</h2>
            <p>Voc√™ dominou a mudan√ßa de perspectiva!</p>
            <div class="math-section">
                <p><strong>Itens Adquiridos (Conceitos-Chave):</strong></p>
                <ul>
                    <li>Diagonaliza√ß√£o √© uma **Mudan√ßa para a Base de Autovetores (Eigenbase)**.</li>
                    <li>Rela√ß√£o fundamental: \(D = P^{-1} A P\).</li>
                    <li>F√≥rmula do "Modo Deus": \(A^k = PD^kP^{-1}\).</li>
                </ul>
            </div>
            <p>A estrutura fundamental do universo da √Ålgebra Linear est√° aberta para voc√™!</p>
          </section>
        </section>

        <!-- Slide Final: Easter Egg -->
        <section>
            <h2>Easter Egg: Aplica√ß√µes</h2>
            <div class="lore-section">
                <div class="lore-label">EASTER EGG</div>
                <p><strong>Onde a √Ålgebra Linear √© o "Motor do Jogo" no Mundo Real</strong></p>
                <p>
                    Os conceitos de autovalores e autovetores n√£o s√£o apenas o final do jogo; eles s√£o o motor de inova√ß√µes que usamos todos os dias.
                </p>
            </div>
            <div class="math-section">
                <p>Exemplos de aplica√ß√£o:</p>
                <ul>
                    <li><strong>Google PageRank</strong>: O ranking de uma p√°gina √© um componente do autovetor principal de uma matriz gigantesca que representa os links da web.</li>
                    <li><strong>Machine Learning (PCA)</strong>: Reduz a dimensionalidade de dados (ex: imagens) encontrando os autovetores da matriz de covari√¢ncia.</li>
                    <li><strong>Engenharia Estrutural</strong>: Autovalores determinam as frequ√™ncias de vibra√ß√£o de uma estrutura, ajudando a prevenir colapsos.</li>
                </ul>
            </div>
        </section>
      </div>
    </div>
    
    <script>
      // Inicializa√ß√£o do Reveal.js
      window.onload = function () {
        Reveal.initialize({
          controls: true,
          progress: true,
          center: true,
          hash: true,
          plugins: [RevealMath.MathJax3],
          width: '90%',
          height: '100%',
          margin: 0.02,
          minScale: 0.45,
          maxScale: 1.5,
          transition: 'fade',
        });
      };
      
      // Script para a visualiza√ß√£o de Autovetores
      let eigenCanvas, eigenCtx, transformed = false;
      const A = [[1.5, 0.5], [0.5, 1.5]]; // Matriz de transforma√ß√£o
      const v1 = [1, 1];  // Autovetor 1 (lambda = 2)
      const v_other = [0.2, 1]; // Outro vetor
      const origin = { x: 300, y: 200 };
      const scale = 50;

      function drawVector(ctx, vector, color, label) {
          ctx.beginPath();
          ctx.moveTo(origin.x, origin.y);
          ctx.lineTo(origin.x + vector[0] * scale, origin.y - vector[1] * scale);
          ctx.strokeStyle = color;
          ctx.lineWidth = 3;
          ctx.stroke();
          ctx.fillStyle = color;
          ctx.font = "20px 'VT323'";
          ctx.fillText(label, origin.x + vector[0] * scale + 5, origin.y - vector[1] * scale);
      }
      
      function multiplyMatrixVector(M, v) {
        return [
          M[0][0] * v[0] + M[0][1] * v[1],
          M[1][0] * v[0] + M[1][1] * v[1]
        ];
      }

      function drawEigenDemo() {
        if (!eigenCtx) return;
        eigenCtx.clearRect(0, 0, eigenCanvas.width, eigenCanvas.height);
        
        // Desenha eixos
        eigenCtx.strokeStyle = '#333';
        eigenCtx.lineWidth = 1;
        eigenCtx.beginPath();
        eigenCtx.moveTo(0, origin.y); eigenCtx.lineTo(eigenCanvas.width, origin.y);
        eigenCtx.moveTo(origin.x, 0); eigenCtx.lineTo(origin.x, eigenCanvas.height);
        eigenCtx.stroke();
        
        if (transformed) {
          // Desenha a linha do autovetor
          eigenCtx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
          eigenCtx.beginPath();
          eigenCtx.moveTo(origin.x - v1[0]*scale*3, origin.y + v1[1]*scale*3);
          eigenCtx.lineTo(origin.x + v1[0]*scale*3, origin.y - v1[1]*scale*3);
          eigenCtx.stroke();
          
          drawVector(eigenCtx, multiplyMatrixVector(A, v1), '#FFFF00', 'Av1 (Caminho √ìtimo)');
          drawVector(eigenCtx, multiplyMatrixVector(A, v_other), '#FF00FF', 'Av_outro');
        } else {
          // Desenha a linha do autovetor
          eigenCtx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
          eigenCtx.beginPath();
          eigenCtx.moveTo(origin.x - v1[0]*scale*3, origin.y + v1[1]*scale*3);
          eigenCtx.lineTo(origin.x + v1[0]*scale*3, origin.y - v1[1]*scale*3);
          eigenCtx.stroke();
          
          drawVector(eigenCtx, v1, '#00FFFF', 'v1 (Caminho √ìtimo)');
          drawVector(eigenCtx, v_other, '#FF88FF', 'v_outro');
        }
      }

      function initEigenDemo() {
        eigenCanvas = document.getElementById('eigenvectorVisualization');
        if (!eigenCanvas) return;
        eigenCtx = eigenCanvas.getContext('2d');
        transformed = false;
        drawEigenDemo();
      }

      window.applyTransformation = function() {
        transformed = true;
        drawEigenDemo();
      };
      
      window.resetTransformation = function() {
        transformed = false;
        drawEigenDemo();
      };
      
      Reveal.on('slidechanged', event => {
        if (event.currentSlide.querySelector('#eigenvectorVisualization')) {
          initEigenDemo();
        }
      });
    </script>
  </body>
</html>